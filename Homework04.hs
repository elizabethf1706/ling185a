{-# OPTIONS_GHC -Werror=incomplete-patterns #-}
module Homework04 where

import Prelude(Show, Num(..), Eq(..), Ord(..), Char, Int, undefined)
import Prelude(Bool(..), (&&), (||), not, or, and)
import Prelude(Maybe(..))
import Prelude((++), map, elem, filter,last)

-- filter removes from a list elements that don't satisfy the given predicate
--      filter :: (a -> Bool) -> [a] -> [a]
--      e.g. filter (\x -> x > 3) [1,2,3,4,5]   ==>   [4,5]

-- liftA is equivalent to `map'; liftA2 and liftA3 generalize to functions of more arguments.
--      liftA :: (a -> b) -> [a] -> [b]
--      liftA2 :: (a -> b -> c) -> [a] -> [b] -> [c]
--      liftA3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
import Control.Applicative(liftA, liftA2, liftA3)

-- nub just removes duplicate elements from a list
--      nub :: (Eq a) => [a] -> [a]
--      e.g. nub [1,2,3,1,2,2,3,4,1]   ==>   [1,2,3,4]
import Data.List(nub)

import FiniteStatePart2

---------------------------------------
-- Setup for section 1

type SLG sy = ([sy], [sy], [sy], [(sy,sy)])
data ConstructedState sy = ExtraState | StateForSymbol sy deriving (Eq, Show)

slg1 :: SLG SegmentCV
slg1 = ([C,V], [C], [V], [(C,C),(C,V),(V,V)])

helper :: (Eq sy) => SLG sy -> [sy] -> Bool
helper slg@(_,_,finalstate,allowable) w = case w of 
    [] -> False
    [x] -> (x,x) `elem` allowable
    x:(y:rest2)-> if (x,y) `elem` allowable 
                then helper slg (y:rest2)
                else False
slg2 :: SLG Int
slg2 = ([1,2,3], [1,2,3], [1,2,3], [(1,1),(2,2),(3,3),(1,2),(2,1),(1,3),(3,1)])

generatesSLG :: (Eq sy) => SLG sy -> [sy] -> Bool
generatesSLG slg@(alphabet,initial,finalstate,allowable) w = case w of 
    [] -> False
    x:rest -> elem (x) initial && helper slg w && elem (last w) finalstate
-- note to change last w.

-- creats a fsa from a slg.
--slg1 = ([C,V], [C], [V], [(C,C),(C,V),(V,V)])

-- from our given example it looks like we 
slgToFSA :: SLG sy-> Automaton (ConstructedState sy) sy
slgToFSA slg =
 let (symbols, starts, ends, transitions) = slg in
 let statesOfFSA = ExtraState : (map (\x-> StateForSymbol x) symbols) in
 (statesOfFSA, symbols, [ExtraState], endsFromSLG slg, deltaFromSLG slg)
-- basically teacher gave us/ did statesoffsa, symbols, extrastate, and we are implementing
--endsfrom slg and deltafromslg.

endsFromSLG :: SLG sy-> [ConstructedState sy]
endsFromSLG (symbols, starts, ends, transitions) = map StateForSymbol ends
-- equal to (map (\x-> StateForSymbol x) ends) 

deltaFromSLG :: SLG sy-> [(ConstructedState sy, sy, ConstructedState sy)]
deltaFromSLG (symbols, starts, ends, transitions) = 
    map (\x -> (ExtraState, x, StateForSymbol x)) starts ++ 
    map (\(x,y)-> (StateForSymbol x, y, StateForSymbol y)) transitions 
---------------------------------------
-- Setup for section 2

data Either a b = First a | Second b deriving (Show,Eq)

re1 :: RegExp Char
re1 = Concat (Alt (Lit 'a') (Lit 'b')) (Lit 'c')

re2 :: RegExp Char
re2 = Star re1

re3 :: RegExp Int
re3 = Star (Concat ZeroRE (Lit 3))

re4 :: RegExp Int
re4 = Concat (Alt (Lit 0) (Lit 1)) (Star (Lit 2))

unionFSAs :: (Eq sy) => EpsAutomaton st1 sy-> EpsAutomaton st2 sy-> EpsAutomaton (Either st1 st2) sy
unionFSAs (states1,syms1,i1,f1,delta1) (states2,syms2,i2,f2,delta2) =
    let states = (map First states1) ++ (map Second states2) in
    let syms = nub (syms1 ++ syms2) in
    let i = (map First i1) ++ (map Second i2) in
    let f = (map First f1) ++ (map Second f2) in
    let delta = (map (\(x,y,z)-> (First x, y, First z)) delta1) ++ (map (\(x,y,z)-> (Second x, y, Second z)) delta2) 
    in (states, syms, i, f, delta)
concatFSAs ::(Eq sy) => EpsAutomaton st1 sy-> EpsAutomaton st2 sy-> EpsAutomaton (Either st1 st2) sy
concatFSAs (states1,syms1,i1,f1,delta1) (states2,syms2,i2,f2,delta2) =
    let states = (map First states1) ++ (map Second states2)
    let syms =  nub (syms1 ++ syms2) in in
    let i = (map First i1)  in
    let f = (map Second f2) in
    let epsilontrans = map \x -> (map First f1) -> map Second i2   
    let delta = liftA2 (\x -> \y-> (x,Nothing,y)) 
    epsilontrans ++
    (map (\(x,y,z)-> (First x, y, First z)) delta1) ++ 
    (map (\(x,y,z)-> (Second x, y, Second z)) delta2) 
        in (states, syms, i, f, delta)
 -- transition needed epsilon
efsa21 :: EpsAutomaton Int Char
efsa21 = ([10,20,21,30,31,32], ['a','b'], 
                  [10], [20,30], [(10, Just 'a', 10), (10, Nothing, 20),  (10, Nothing, 30), 
                                  (20, Just 'b', 21), (21, Just 'b', 20), 
                                  (30, Just 'b', 31), (31, Just 'b', 32), (32, Just 'b', 30) ]
                 )
efsa_xyz :: EpsAutomaton Int Char
efsa_xyz = ([0,1], ['x','y','z'], [0], [1], [(0, Just 'x', 0), 
(0, Just 'y', 1), (0, Nothing, 1), (1, Just 'z', 1)])
abbbxxxyz 
can be generated by 
(10,just a, 100 -> (10, nothing, 20) -> (20 just b 21)  ->(21 just b 20)  -> (20 just b 21)
in efsa and
(0, Just 'x', 0)-> (0, Just 'x', 0)  -> (0, Just 'x', 0)->(0, Just 'x', 0)->(0, Just 'y', 1)->(1, Just 'z', 1).
it is just checking for transition 1 if it can be generated, and then it checks if evertthing in t2 can be generated.
------------------------------------------------------------------
------------------------------------------------------------------
-- IMPORTANT: Please do not change anything above here.
--            Write all your code below this line.

